#!/bin/sh
# ==================================
# DAJIN - Genotyping software using Nanopore long-read sequencer for genome-edited samples
# Version: 2.0.2
# License: MIT
# Written by Akihiro Kuno
# <https://github.com/akikuno/DAJIN2>.
# ==================================
find ./ -type d |
  grep -e "./library" -e "./script" -e "./document" -e "./utils" |
  grep -v -e "past" -e ".DAJIN_temp" |
  sort -u |
  sed "s|^./|.DAJIN_temp/|" |
  xargs mkdir -p
cat <<'EMBED' >.DAJIN_temp/document/README_JP.md

<p align="center">
<img src="https://github.com/akikuno/DAJIN/blob/master/misc/images/DAJIN-logo.png" width="90%">
</p>

[![MIT License](http://img.shields.io/badge/license-MIT-blue.svg?style=flat)](LICENSE)

## 特徴

- **移植性**：Windows10 (WSL), Linux, macOS
- **低依存性**：minimap2とsamtoolsのみ必要とします
- **高速**： DAJINの100倍高速です

## セットアップ

### 動作環境

LinuxまたはWindows 10 ([WSL](https://docs.microsoft.com/ja-jp/windows/wsl/install-win10))で動作確認をしています.  
検証済みの環境は[こちら](https://github.com/akikuno/DAJIN/blob/master/docs/TESTED_SYSTEMS.md)です.  

### `conda`をインストールします


wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
chmod +x Miniconda3-latest-Linux-x86_64.sh
./Miniconda3-latest-Linux-x86_64.sh

condaおよびインストールについての詳細は[こちら](https://docs.conda.io/projects/conda/en/latest/)にございます.  


### DAJINをダウンロードします

git clone https://github.com/akikuno/DAJIN.git

または下記URLでZIPファイルをダウンロードしてください.  

https://github.com/akikuno/DAJIN/archive/master.zip

### DAJINをダウンロードします


## 利用方法

### 入力ファイルの用意

以下のような入力ファイルを作製します.  

design=DAJIN/example/design.txt
input_dir=DAJIN/example/demultiplex
control=barcode01
genome=mm10
grna=CCTGTCCAGAGTGGGAGATAGCC,CCACTGCTAGCTGTGGGTAACCC
output_dir=DAJIN_cables2
threads=10
filter=on

各項目の情報は以下のとおりです. 各項目は順不同です.  

- **desing**: 考えられる遺伝型の配列を記載したFASTA形式のテキストファイルです.  ">wt"と">target"の2つは含まれている必要があります. 
- **input_dir**: demultiplex済みのFASTA/FASTQファイルを含むディレクトリです. 
- **control**: 野生型コントロールのバーコード番号です. 
- **genome**: `mm10`, `hg38`等の参照ゲノムです. 
- **grna**: PAMを含むgRNA配列です. 2つ以上の配列はコンマ（,）で区切ります. 
- **output_dir（オプショナル）**: 結果を保存するディレクトリの名前です. デフォルトは`DAJIN_results`です. 
- **threads（オプショナル）**: DAJINに使用するCPUスレッド数です. デフォルトでは`3分の2`を使用します. 
- **filter（オプショナル**: on/off）: マイナーアレル（3%以下）を解析から除きます. デフォルトは"on"です. 


### DAJINの実行

./DAJIN/DAJIN.sh -f [入力ファイルのPATH]

下記のコマンドで例を実行します.

./DAJIN/DAJIN.sh -i DAJIN/example/design.txt

### 結果のレポートについて

DAJINは2つのファイル（`Details.csv`, `Details.pdf`）と2つのフォルダ（`BAM`, `Consensus`）を出力します. 

#### Details.csv

`Details.csv` はアレル情報を記載しています.

| Sample    |  Allele ID |  % of reads |  Allele type  |  Indel |  Large indel |  Design |
|-----------|------------|-------------|---------------|--------|--------------|---------|
| barcode01 | 1          | 100         | wt            | -      | -            | -       |
| barcode02 | 1          | 11.8        | abnormal      | +      | +            | -       |
| barcode02 | 2          | 88.2        | target        | -      | -            | +       |
| barcode03 | 1          | 9.9         | abnormal      | +      | +            | -       |
| barcode03 | 2          | 38.5        | abnormal      | +      | +            | -       |
| barcode03 | 3          | 51.6        | flox_deletion | -      | -            | -       |

#### Details.pdf

`Details.pdf`は上記CSVを可視化した以下のような図です.  

<img src="https://github.com/akikuno/DAJIN/blob/master/misc/images/Details.png" width="75%">  

barcode01は野生型コントロールです. barcode02とbarcode03はfloxノックインのゲノム編集を施したファウンダーマウスの結果です.  
barcode02のほぼ全てのアレルがintact target （flox以外の異常な変異の入っていないアレル）であることから、このマウスは目的のfloxアレルをホモでもつマウスの候補と考えられます.  

#### Consensus

`Conseusus` フォルダーには各アレルのコンセンサス配列が保存されています.  
ファイル形式はFASTAおよびHTMLです.  

HTMLでは色付けされた変異情報が表示されます.  

<a href="https://htmlpreview.github.io/?https://github.com/akikuno/DAJIN/blob/master/misc/images/tyr_c140cg.html" target= _blank rel= noopener> こちらは点変異のコンセンサス配列です. </a>

#### BAM

`BAM` フォルダーには解析したサンプルの全アレルおよび各アレルごとのBAMファイルが保存されています.  
この`BAM`ファイルは[IGV](http://software.broadinstitute.org/software/igv/)で可視化できます.  

EMBED
cat <<'EMBED' >.DAJIN_temp/document/dependencies.md
# Dependencies

+ samtools (1.10)
+ minimap2 (2.17-r941)
+ Python (3.7.6)
  + numpy (1.18.5)
  + pandas (1.0.5)
  + scikit-learn (0.23.1)
  + plotnine (0.7.0)

> The number in the parenthesis represents the tested software version.
EMBED
cat <<'EMBED' >.DAJIN_temp/document/tested_systems.md
# Tested system information

We have tested DAJIN2 works in the following systems:

## Linux

---
| OS     | Ubuntu 18.04.3 LTS x86_64            |
| ------ | ------------------------------------ |
| Kernel | 5.0.0-29-generic                     |
| Shell  | bash 4.4.20                          |
| CPU    | Intel Xeon Gold 5220 (72) @ 3.900GHz |
| GPU    | NVIDIA GeForce RTX 2080 Ti x4        |
| Memory | 192 GB                               |
---
| OS     | Linux Mint 20 x86_64            |
| ------ | ------------------------------- |
| Kernel | 5.4.0-42-generic                |
| Shell  | bash 5.0.17                     |
| CPU    | AMD Ryzen 7 2700X (16) @ 3.700G |
| GPU    | NVIDIA GeForce GTX 1080 Ti      |
| Memory | 64 GB                           |

## macOS

## Windows 10 (WSL2)

---
| OS     | Ubuntu 18.04.5 LTS on Windows 10 x86_64 |
| ------ | --------------------------------------- |
| Kernel | 4.19.104-microsoft-standard             |
| Shell  | bash 4.4.20                             |
| CPU    | Intel Xeon E3-1535M v6 (8) @ 3.095GHz   |
| Memory | 64 GB                                   |
---
EMBED
cat <<'EMBED' >.DAJIN_temp/document/troubleshootings.md
# Troubleshootings

## line feed

DAJIN: 7: set: Illegal option -

This error may be caused by `CRLF`.

Please open `DAJIN` by your text editor (e.g. Visual Studio Code) and change the line feed from `CRLF` to `LF`.  

## samtools

EMBED
cat <<'EMBED' >.DAJIN_temp/document/usage.md
Usage:

  DAJIN [options] -a <alleles.fasta> -c <control.fastq> -s <sample.fastq>

Example:

  DAJIN \
    -a example/alleles.fa \
    -c example/fastq/barcode01.fq.gz \
    -s example/fastq/barcode02.fq.gz \
    -g mm10 \
    -o DAJIN_example \
    -t 4

Mandatory arguments:

  -a|--alleles <string>
    Name of a multi-fasta file describing DNA sequence of each alleles in specific regions of interest.

  -c|--control <string>
    Name of a fastq file from a control sample.
    Acceptable formats include gzipped FASTQ and FASTQ.

  -s|--sample <string>
    Name of a fastq file from an experimental sample.
    Acceptable formats include gzipped FASTQ and FASTQ.

Optional arguments (defaults in parentheses):

  -g|--genome <string>
    Name of UCSC genome releases.
    The available genomes are listed at https://genome.ucsc.edu/FAQ/FAQreleases.html#release1

  -t|--threads <integer>
    Number of threads to use (1)

  -o|--output <string>
    Output directory (DAJIN_results)

See the further information: <https://github.com/akikuno/DAJIN2>

EMBED
cat <<'EMBED' >.DAJIN_temp/document/version.md
DAJIN - Genotyping software using Nanopore long-read sequencer for genome-edited samples
Version: 2.0.2
License: MIT
Written by Akihiro Kuno
<https://github.com/akikuno/DAJIN2>.
EMBED
cat <<'EMBED' >.DAJIN_temp/library/calcHotelling.sh
#!/bin/sh

calcHotelling() (
  if [ -p /dev/stdin ] && [ _"$*" = _"" ]; then
    cat -
  elif [ -r "$*" ]; then
    cat "$*"
  else
    echo "$*"
  fi |
    awk '{
      data[NR]=$0
      sum+=$1
    } END {
      mean=sum/NR
      for(i=1;i<=NR;i++) {
        residual+=(data[i]-mean)^2
      }
      var=residual/NR
      for(i=1;i<=NR;i++) {
        hotelling=(data[i]-mean)^2/var
        print hotelling
      }
    }'
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/colTable.R
#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly = TRUE)
if (length(args) > 0) {
  df <- read.table(args[1], sep = ",", header = FALSE, row.names = 1)
} else {
  df <- read.table(".DAJIN_temp/tmp_expansion_barcode30_inversion.csv", sep = ",", header = FALSE, row.names = 1)
}

list_table <- apply(df, 2, table)

for (idx in seq(length(list_table))) {
  values <- names(list_table[[idx]])
  values <- as.integer(values)
  for (val in values[values > 0]) {
    df[[idx]][df[[idx]] == val] <-
      list_table[[idx]][values == val]
  }
}

write.table(df,
  file = "",
  sep = ",", col.names = FALSE, row.names = TRUE, quote = FALSE
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/formatFasta.sh
#!/bin/sh

formatFasta() {
  cat "$1" |
    awk 'BEGIN{RS=">"} {
      $1=">" $1 " "
      for(i=1;i<=NF;i++) printf $i
      print ""
      }' |
    awk 'NF==2'
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/general.sh
#!/bin/sh

error_exit() {
  echo "ERROR: $1" >&2
  echo "ERROR: $1" >>log_DAJIN.txt
  [ "${TEST:-}" ] || rm -rf .DAJIN_temp/ 2>/dev/null
  exit 1
}

terminate() {
  trap '' TERM
  kill -TERM 0
  [ "${TEST:-}" ] || rm -rf .DAJIN_temp/ 2>/dev/null
  exit "$1"
}
trap "terminate 130" INT
trap "terminate 143" TERM

timestamp() {
  echo "$(date +'%Y-%m-%d %H:%M:%S') | $*"
}

load_control() {
  find "$1" -type f |
    while read -r line; do
      output=${line#/tmp/}
      output=${output%.gz}
      gzip -dc "$line" >.DAJIN_temp/"$output"
    done
}

save_control() {
  find "$1" -type f |
    grep "$control_name" |
    while read -r line; do
      output=${line#\.DAJIN_temp/}.gz
      gzip -c "$line" >/tmp/"$output"
    done
}

open() {
  if file "$1" | grep -q gzip; then
    gzip -dc "$1"
  else
    cat "$1"
  fi
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/maskFastq.sh
#!/bin/sh

maskFastq() {
  if [ -p /dev/stdin ] && [ _"$*" = _"" ]; then
    cat -
  elif [ -r "$*" ]; then
    cat "$*"
  else
    echo "$*"
  fi |
    sed "s/^@/\n@/" |
    awk 'BEGIN{RS=""; FS="\n"; OFS="\n"} {
    split($2, sequence, "")
    n=split($NF, quality, "")
    for(i=1 && seq=""; i<=n; i++) {
      if (quality[i] ~ "[!\"#$%&'\''()*]") {
        seq=seq "N"
      }
      else {
        seq=seq sequence[i]
      }
    }
    $2=seq
  }1'
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/midsToscore.sh
#!/bin/sh
# shellcheck disable=SC1091,SC2120

################################################################################
# input: MIDS (id, MIDS)
# output: MIDS score (id, I, D, S)
################################################################################

expansion() {
  if [ -p /dev/stdin ] && [ "$#" -eq 0 ]; then
    cat -
  elif [ -r "$1" ]; then
    cat "$1"
  else
    echo "$*"
  fi |
    awk -F, '
    function mids_score(I,D,S) {
      $(i+(LEN)*0)=I
      $(i+(LEN)*1)=D
      $(i+(LEN)*2)=S
    }
    function invToD(data) {
      id=$1
      gsub(/[mids]/, "D", $0)
      $1=id
    }
    BEGIN {OFS=","} {
    LEN=NF-1
    invToD($0)
    for(i=2;i<=NF;i++) {
      if($i=="M")
        mids_score(0,0,0)
      else if ($i~/[0-9]+M/) {
        sub("M$","",$i)
        mids_score($i,0,0)
        }
      else if ($i~/[0-9]+D/) {
        sub("D$","",$i)
        mids_score($i,1,0)
      }
      else if ($i~/[0-9]+S/) {
        sub("S$","",$i)
        mids_score($i,0,1)
      }
      else if($i=="D") {
        mids_score(0,1,0)
      }
      else if($i=="S") {
        mids_score(0,0,1)
      }
    }
  }1'
}

mutToat() {
  awk '
    BEGIN {
      FS=","
      OFS=""
    } {
    $1=$1","
    ins_nf=(NF-1)/3
    for (i=2; i<=ins_nf; i++) {
      $i=$i","
    }
    for (i=ins_nf+1; i<=NF; i++) {
      if ($i>0 && $(i+1)>0)
        $i="@"
      else if ($(i-1)=="@" && $i==1)
        $i="@,"
      else
        $i=$i","
    }
    sub(",$", "", $NF)
  }1'
}

atToscore() {
  awk '
    BEGIN {
      FS=","
      OFS=","
    } {
    for (i=2; i<=NF; i++) {
      n=""
      if ($i ~ /@/) {
        num=length($i)
        for (j=1; j<=num; j++) n=n num ","
        sub(",$", "", n)
        $i=n
      }
    }
  }1'
}

rowScore() {
  cat "$1" |
    mutToat |
    atToscore
}

colScore() {
  Rscript --vanilla .DAJIN_temp/library/colTable.R "$1"
}

rowColSums() {
  Rscript --vanilla .DAJIN_temp/library/rowColSums.R "$1" "$2"
}

midsToscore() {
  mkdir -p .DAJIN_temp
  suffix="${1##*/}"
  expansion "$1" >.DAJIN_temp/tmp_expansion_"$suffix"
  rowScore .DAJIN_temp/tmp_expansion_"$suffix" >.DAJIN_temp/tmp_row_"$suffix"
  colScore .DAJIN_temp/tmp_expansion_"$suffix" >.DAJIN_temp/tmp_col_"$suffix"
  rowColSums .DAJIN_temp/tmp_row_"$suffix" .DAJIN_temp/tmp_col_"$suffix"
  # rm .DAJIN_temp/tmp_*"$suffix"
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/rowColSums.R
#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly = TRUE)

df_row <- read.table(args[1], sep = ",", header = FALSE, row.names = 1)
df_col <- read.table(args[2], sep = ",", header = FALSE, row.names = 1)

df <- df_row + df_col

write.table(df,
  file = "",
  sep = ",", col.names = FALSE, row.names = TRUE, quote = FALSE
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/samToPhred.sh
#!/bin/sh
EMBED
cat <<'EMBED' >.DAJIN_temp/library/samTomids.sh
#!/bin/sh
# shellcheck disable=SC1091,SC2120

################################################################################
# input: SAM file using `minimap2 -ax splice --cs=long`
# output: Match(M), Insertion(1M), Deletion(D), Substitution(S), Inversion (mids) and "= (null)"
################################################################################

fmt_sam() {
  cat - |
    awk '
    /^@SQ/ {
      for(i=1;i<=NF;i++) {
        if($i ~ /^SN:/) allele=$i
        if($i ~ /^LN:/) reflen=$i
      }
      sub(/.*SN:/,"", allele)
      sub(/.*LN:/,"", reflen)
    }
    /cs:Z:=/ {
      id=$1; flag=$2; start=$4
      for(i=1;i<=NF;i++) if ($i ~ /^cs:Z:=/) cstag=$i
      sub("cs:Z:=","",cstag)
      gsub("=", " ", cstag)
      gsub(/\+/, " ", cstag)
      gsub(/\-/, " -", cstag)
      gsub(/\*/, " *", cstag)
      gsub("~", " ~", cstag)
      $1=id","flag","start","allele","reflen
      $2=cstag
      print $1,$2
    }' |
    sort -t "," -k 3,3n
}

matchToM() {
  awk '{for(i=2;i<=NF;i++) gsub(/[ACGT]/, "M ", $i)}1'
}

subToS() {
  awk '{for(i=2;i<=NF;i++) gsub(/\*[acgt][acgt]/, "S ", $i)}1'
}

delToD() {
  awk '{
      for(i=2;i<=NF;i++) {
        if($i ~ /^-/) {
          str=""
          for(j=1;j<=int(length($i)-1);j++) str=str "D "
          $i=str
        }
      }}1'
}

insToNum() {
  awk '{
    for(i=3;i<=NF;i++) {
      if($i~/^[acgt]/){
        $i=length($i) $(i+1)
        $(i+1)=""
      }
    }}1'
}

padding() {
  awk '{
    start=$2-1
    end=$3
    len=NF-3+start
    pad_start=""
    pad_end=""
    for(i=1;i<=start;i++) pad_start=pad_start "D "
    $4=pad_start $4
    for(i=len;i<end;i++) pad_end=pad_end " D"
    $NF=$NF pad_end
  }1' |
    sed "s/  */ /g"
}

spaceTocomma() {
  sed -e "s/  */,/g" -e "s/,$//"
}

samTomids() (
  if [ -p /dev/stdin ] && [ "$#" -eq 0 ]; then
    cat -
  elif [ -r "$1" ]; then
    cat "$1"
  else
    echo "$*"
  fi |
    # cat test/samTomids/in/test_inv.sam |
    fmt_sam |
    matchToM |
    subToS |
    delToD |
    awk '{$1=$1","}1' |
    #* Large deletion and Inversion -------------------------
    awk -F, '
      function padD(iter,    i,str) {
        for (i=1; i<=iter; i++) str=str " D "
        return str
      }

      function ins_rm(string) {
        gsub("[acgt][acgt]*", "", string)
        return string
      }

      function csCat(c_of, s_of, iter,    i,cs) {
        for(i=1; i<=iter; i++) {
          _cs=c_of[i]
          ins_rm(_cs)
          gap_length=s_of[i+1] - s_of[i] - gsub(/[MIDSmids]/, "", _cs)
          cs=cs c_of[i] padD(gap_length)
        }
        cs=cs c_of[iter+1]
        return cs
      }

    {
      num_of_alignment[$1]++
      start_of[$1]=start_of[$1]","$3
      allele=$4
      reflen=$5
      cstag_of[$1]=cstag_of[$1]","$6
    } END {
      for (read_id in num_of_alignment) {
        sub(/^,/, "" ,start_of[read_id])
        sub(/^,/, "" ,cstag_of[read_id])
        split(start_of[read_id], s_of, ",")
        split(cstag_of[read_id], c_of, ",")
        #* normal
        if (num_of_alignment[read_id]==1) {
          cs=c_of[1]
        }
        #* large deletion
        else if (num_of_alignment[read_id]==2) {
          if (allele !~ /(control)|(wt)/) {
            c_of[1] = padD(gsub(/[MIDS]/, "", c_of[1]))
            c_of[2] = padD(gsub(/[MIDS]/, "", c_of[2]))
          }
          cs=csCat(c_of, s_of, 1)
          }
        #* inversion
        else if (num_of_alignment[read_id]==3) {
          c_of[2] = tolower(c_of[2])
          cs=csCat(c_of, s_of, 2)
        }
      print read_id, s_of[1], reflen, cs
    }}' |
    insToNum |
    padding |
    spaceTocomma |
    awk -F, 'NF==$3+3' |
    cut -d, -f 1,4- |
    grep -v "^$" |
    sort -t,
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/scoreToScalar.sh
#!/bin/sh

scoreToScalar() {
  cat "$1" |
    awk -F, 'BEGIN {OFS=","} {
    sum=0
    for(i=2; i<=NF; i++) sum+=$i
    print $1, log(sum/(NF-1))
  }'
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/svLof.py
import sys
import pandas as pd
from sklearn.neighbors import LocalOutlierFactor
import argparse

################################################################################
# Input
################################################################################

parser = argparse.ArgumentParser()
parser.add_argument("-c", "--control", default=".DAJIN_temp/classif/tmp_control")
parser.add_argument("-s", "--sample", default=".DAJIN_temp/classif/tmp_control")
parser.add_argument("-t", "--threads", default="1")
args = parser.parse_args()

df_control = pd.read_csv(args.control, header=None)
df_sample = pd.read_csv(args.sample, header=None)
threads = int(args.threads)

################################################################################
# LOF
################################################################################

lof = LocalOutlierFactor(
    n_neighbors=20,
    algorithm="auto",
    leaf_size=30,
    metric="euclidean",
    contamination="auto",
    novelty=True,
    n_jobs=threads,
)

lof.fit(df_control)

output = pd.Series(lof.predict(df_sample))

################################################################################
# Output
################################################################################

output.to_csv(sys.stdout, index=False, header=False)
EMBED
. .DAJIN_temp/library/calcHotelling.sh
. .DAJIN_temp/library/formatFasta.sh
. .DAJIN_temp/library/general.sh
. .DAJIN_temp/library/maskFastq.sh
. .DAJIN_temp/library/midsToscore.sh
. .DAJIN_temp/library/samToPhred.sh
. .DAJIN_temp/library/samTomids.sh
. .DAJIN_temp/library/scoreToScalar.sh
ARGS="$*" && export ARGS
cat <<'EMBED' >.DAJIN_temp/script/01-init/01-init.sh
#!/bin/sh

set -eu
umask 0022
export LC_ALL=C

[ "${BASH_VERSION:-}" ] && set -o posix -o pipefail
[ "${ZSH_VERSION:-}" ] && setopt shwordsplit interactivecomments

timestamp "DAJIN $*" >log_DAJIN.txt
EMBED
cat <<'EMBED' >.DAJIN_temp/script/02-args/01-parse.sh
#!/bin/sh

[ "$#" -eq 0 ] && grep -v '```' .DAJIN_temp/document/usage.md && exit 0

while [ "$#" -gt 0 ]; do
  case "$1" in
  -h | --help)
    grep -v '```' .DAJIN_temp/document/usage.md
    exit 0
    ;;
  -v | --version)
    grep -v '```' .DAJIN_temp/document/version.md
    exit 0
    ;;

  #--- parse arguments
  -a | --alleles)
    alleles="$2"
    shift
    ;;
  -c | --control)
    control="$2"
    shift
    ;;
  -s | --sample)
    sample="$2"
    shift
    ;;
  -g | --genome)
    genome="$2"
    shift
    ;;
  -o | --output)
    output_dir="$2"
    shift
    ;;
  -t | --threads)
    threads="$2"
    shift
    ;;

  #--- error handling
  -*) echo "Unrecognized option: $1" && exit 1 ;;
  *) echo "Unrecognized argument: $1" && exit 1 ;;
  esac
  shift
done

################################################################################
# Check arguments
################################################################################

# Check mandatory arguments ------------

echo "$ARGS" |
  grep -q -e "\-a " -e "\--alleles " ||
  error_exit "-a|--alleles argument is required"

[ -r "$alleles" ] || error_exit "$alleles is not found"

grep -q -e '>wt' -e ">control" "$alleles" ||
  error_exit "$alleles must include '>control' or '>wt'"

echo "$ARGS" |
  grep -q -e "\-c " -e "\--control " ||
  error_exit "-c|--control argument is required"

[ -r "$control" ] || error_exit "$control is not found"

echo "$ARGS" |
  grep -q -e "\-s " -e "\--sample " ||
  error_exit "-s|--sample argument is required"

[ -r "$sample" ] || error_exit "$sample is not found"

control_name="$(basename "$control" | sed "s/\..*$//" | tr " " "_")"
sample_name="$(basename "$sample" | sed "s/\..*$//" | tr " " "_")"

[ "${control_name:-}" ] || error_exit "$control is an invalid file name."
[ "${sample_name:-}" ] || error_exit "$sample is an invalid file name"

# Check optional arguments ------------
EMBED
cat <<'EMBED' >.DAJIN_temp/script/02-args/02-depend.sh
#!/bin/sh

################################################################################
# Chech dependencies
################################################################################

# curl or wget ------------------------------------------------

if type wget >/dev/null 2>&1; then
  CMD_CHECK='wget -q -O - --spider --tries=2 --wait=1 --timeout=5'
  CMD_GET='wget -q -O -'
elif type curl >/dev/null 2>&1; then
  CMD_CHECK='curl --retry 2 --retry-delay 1 -s -o /dev/null -w "%{http_code}"'
  CMD_GET='curl -s'
else
  error_exit 'No HTTP-GET/POST command found.'
fi

# Commands ------------------------------------------------

cat <<EOF |
  minimap2
  samtools
  gzip
  python
EOF
  while read -r CMD; do
    "$CMD" --version >/dev/null 2>&1 || error_exit "$CMD: command not found"
  done

# R packages ----------------------------------------------
# Rscript --slave --vanilla .DAJIN_temp/library/install_pkgs.R 1>/dev/null 2>&1

# Rscript --slave --vanilla -e "installed.packages()" >.DAJIN_temp/rpackages

# cat <<EOF |
#   dbscan
#   ggplot2
#   RColorBrewer
# EOF
#   while read -r RPKG; do
#     grep -q "$RPKG" .DAJIN_temp/rpackages || error_exit "$RPKG: package not found in R"
#   done

# rm .DAJIN_temp/rpackages

# Python packages ----------------------------------------

pip freeze >.DAJIN_temp/pypackages

cat <<EOF |
  numpy
  pandas
  scikit-learn
  hdbscan
  joblib
  plotnine
EOF
  while read -r PYPKG; do
    grep -q "$PYPKG" .DAJIN_temp/pypackages || error_exit "$PYPKG: package not found in Python"
  done

rm .DAJIN_temp/pypackages
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/010-fasta.sh
#!/bin/sh

. .DAJIN_temp/library/formatFasta.sh

mkdir -p .DAJIN_temp/fasta/

formatFasta "${alleles}" |
  while read -r line; do
    output="$(echo ${line#>} | cut -d " " -f 1)"
    echo "$line" | tr " " "\n" >.DAJIN_temp/fasta/"$output".fa
  done
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/015-fastq.sh
#!/bin/sh

mkdir -p .DAJIN_temp/fastq/ /tmp/DAJIN/fastq/

# if find /tmp/fastq/"$control_name"* 1>/dev/null 2>&1; then
#   gzip -dc /tmp/fastq/"$control_name".fq.gz >.DAJIN_temp/fastq/"$control_name".fq
#   open "$sample" | maskFastq >.DAJIN_temp/fastq/"$sample_name".fq
# else
#   {
#     open "$control" | maskFastq >.DAJIN_temp/fastq/"$control_name".fq &
#     open "$sample" | maskFastq >.DAJIN_temp/fastq/"$sample_name".fq &
#     wait
#   } 1>/dev/null 2>&1
#   gzip -c .DAJIN_temp/fastq/"$control_name".fq >/tmp/fastq/"$control_name".fq.gz
# fi

open "$control" >.DAJIN_temp/fastq/"$control_name".fq
open "$sample" >.DAJIN_temp/fastq/"$sample_name".fq
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/020-sam.sh
#!/bin/sh

#----------------------------------------------------------
timestamp "Generate SAM files" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/sam /tmp/DAJIN/sam

find .DAJIN_temp/fasta/*.fa |
  while read -r fasta; do
    allele_name="$(basename ${fasta%.fa})"

    if find /tmp/DAJIN/sam/"$control_name"_"$allele_name".bam 1>/dev/null 2>&1; then
      samtools view /tmp/DAJIN/sam/"$control_name"_"$allele_name".bam \
        >.DAJIN_temp/sam/"$control_name"_"$allele_name".sam
    else
      minimap2 -t "$threads" -ax map-ont "$fasta" .DAJIN_temp/fastq/"$control_name".fq --cs=long 2>/dev/null \
        >.DAJIN_temp/sam/"$control_name"_"$allele_name".sam
      samtools sort -@ "$threads" .DAJIN_temp/sam/"$control_name"_"$allele_name".sam \
        >/tmp/DAJIN/sam/"$control_name"_"$allele_name".bam 2>/dev/null
    fi

    minimap2 -t "$threads" -ax map-ont "$fasta" .DAJIN_temp/fastq/"$sample_name".fq --cs=long 2>/dev/null \
      >.DAJIN_temp/sam/"$sample_name"_"$allele_name".sam
  done
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/030-mids.sh
#!/bin/sh

#----------------------------------------------------------
timestamp "MIDS encoding" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/mids /tmp/DAJIN/mids

multi_samTomids() {
  cmd='. .DAJIN_temp/library/samTomids.sh; samTomids '
  find .DAJIN_temp/sam/"${1:-}"*.sam |
    while read -r line; do
      output="${line%.*}".csv
      output="$(echo $output | sed "s|/sam/|/mids/|")"
      echo "$line" |
        sed "s|^|$cmd|" |
        sed "s|$| >$output \&|"
    done |
    awk -v th="${threads:-1}" '
    {if (NR%(th+1) == 0) print "wait"}
    END {print "wait"}1' |
    sh
}

if find /tmp/DAJIN/mids/"$control_name"* 1>/dev/null 2>&1; then
  multi_samTomids "$sample_name"
  load_control /tmp/DAJIN/mids
else
  multi_samTomids
  save_control .DAJIN_temp/mids
fi
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/002-score.sh
#!/bin/sh

cat <<EOF >>log_DAJIN.txt
==========================================================
Classify alleles...
==========================================================
EOF

#----------------------------------------------------------
timestamp "MIDS scoring" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/score /tmp/DAJIN/score

multi_midsToscore() {
  cmd='. .DAJIN_temp/library/midsToscore.sh; midsToscore '
  find .DAJIN_temp/mids/"${1:-}"*.csv |
    while read -r line; do
      output="${line%.*}".csv
      output="$(echo $output | sed "s|/mids/|/score/|")"
      echo "$line" |
        sed "s|^|$cmd|" |
        sed "s|$| >$output \&|"
    done |
    awk -v th="${threads:-1}" '
    {if (NR%(th+1) == 0) print "wait"}
    END {print "wait"}1' |
    sh
}

if find /tmp/DAJIN/score/"$control_name"* 1>/dev/null 2>&1; then
  multi_midsToscore "$sample_name"
  load_control /tmp/DAJIN/score
else
  multi_midsToscore
  save_control .DAJIN_temp/score
fi
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/003-scalar.sh
#!/bin/sh

mkdir -p .DAJIN_temp/scalar /tmp/DAJIN/scalar

multiscoreToScalar() {
  cmd='. .DAJIN_temp/library/scoreToScalar.sh; scoreToScalar '
  find .DAJIN_temp/score/"${1:-}"* |
    grep -e "$sample_name" -e "$control_name"_wt -e "$control_name"_control |
    while read -r line; do
      output="$(echo $line | sed "s|/score/|/scalar/|")"
      echo "$line" |
        sed "s|^|$cmd|" |
        sed "s|$| >$output \&|"
    done |
    awk -v th="${threads:-1}" '
    {if (NR%(th+1) == 0) print "wait"}
    END {print "wait"}1' |
    sh
}

if find /tmp/DAJIN/scalar/"$control_name"* 1>/dev/null 2>&1; then
  multiscoreToScalar "$sample_name"
  load_control /tmp/DAJIN/scalar
else
  multiscoreToScalar
  save_control .DAJIN_temp/scalar
fi
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/025-classif.sh
#!/bin/sh

#----------------------------------------------------------
timestamp "Allele classification" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/classif

find .DAJIN_temp/scalar/"$sample_name"* |
  while read -r line; do
    allele=$(basename "${line%.csv}" | cut -d_ -f2-)
    awk -v al="$allele" '{print al","$0}' "$line"
  done |
  awk -F, '{
    allele=$1
    read=$2
    score=$3
    if(score_of[read] == "") score_of[read]="inf"
    if(score_of[read]>score) {
      output[read]=$0
      score_of[read]=score
    }} END {
      for(read in output) print output[read]
    }' |
  cat >.DAJIN_temp/classif/"$sample_name".csv
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/030-svcall.sh
#!/bin/sh

#----------------------------------------------------------
timestamp "SV allele detetction" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/sv
. .DAJIN_temp/library/calcHotelling.sh

cat .DAJIN_temp/classif/"$sample_name".csv |
  tee .DAJIN_temp/sv/tmp_sample |
  cut -d, -f3 >.DAJIN_temp/sv/tmp_sample_score

cat .DAJIN_temp/scalar/"$control_name"* |
  cut -d, -f2 |
  calcHotelling |
  awk -F, '$1 < 3.841459' | #qchisq(0.95,1)
  cat >.DAJIN_temp/sv/tmp_control_score

# LOFだと値が小さすぎる（きれいにマッピングされすぎる）リードもSVと判定されてしまうため,
# 中央値よりも値が小さいリードはすべて正常と判定させる.
median_score=$(
  sort -n .DAJIN_temp/sv/tmp_control_score |
    awk -v wc="$(wc -l <.DAJIN_temp/sv/tmp_control_score)" 'NR==int(wc/2)'
)

python .DAJIN_temp/library/svLof.py \
  -c .DAJIN_temp/sv/tmp_control_score \
  -s .DAJIN_temp/sv/tmp_sample_score \
  -t "$threads" |
  awk '{($1 == 1) ? $1="normal" : $1="SV"}1' |
  paste -d, - .DAJIN_temp/sv/tmp_sample |
  awk -F, -v median="$median_score" '{
    if($1=="SV" && $NF<median) $1="normal"
    if($1=="SV") $2="SV"
    print $2","$3
   }' |
  cat >.DAJIN_temp/sv/"$sample_name".csv

rm .DAJIN_temp/sv/tmp*
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/040-clustering.sh
#!/bin/sh

echo END
exit 0
EMBED
. .DAJIN_temp/script/01-init/01-init.sh
. .DAJIN_temp/script/02-args/01-parse.sh
. .DAJIN_temp/script/02-args/02-depend.sh
. .DAJIN_temp/script/03-preprocess/010-fasta.sh
. .DAJIN_temp/script/03-preprocess/015-fastq.sh
. .DAJIN_temp/script/03-preprocess/020-sam.sh
. .DAJIN_temp/script/03-preprocess/030-mids.sh
. .DAJIN_temp/script/04-phasing/002-score.sh
. .DAJIN_temp/script/04-phasing/003-scalar.sh
. .DAJIN_temp/script/04-phasing/025-classif.sh
. .DAJIN_temp/script/04-phasing/030-svcall.sh
. .DAJIN_temp/script/04-phasing/040-clustering.sh
