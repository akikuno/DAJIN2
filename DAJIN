#!/bin/sh
# ==================================
# DAJIN - Genotyping software using Nanopore long-read sequencer for genome-edited samples
# Version: 2.0.2
# License: MIT
# Written by Akihiro Kuno
# <https://github.com/akikuno/DAJIN2>.
# ==================================
find ./ -type d |
  grep -e "./library" -e "./script" -e "./document" -e "./utils" |
  grep -v -e "past" -e ".DAJIN_temp" |
  sort -u |
  sed "s|^./|.DAJIN_temp/|" |
  xargs mkdir -p
cat <<'EMBED' >.DAJIN_temp/document/README_JP.md

<p align="center">
<img src="https://github.com/akikuno/DAJIN/blob/master/misc/images/DAJIN-logo.png" width="90%">
</p>

[![MIT License](http://img.shields.io/badge/license-MIT-blue.svg?style=flat)](LICENSE)

## 特徴

- **移植性**：Windows10 (WSL), Linux, macOS
- **低依存性**：minimap2とsamtoolsのみ必要とします
- **高速**： DAJINの100倍高速です

## セットアップ

### 動作環境

LinuxまたはWindows 10 ([WSL](https://docs.microsoft.com/ja-jp/windows/wsl/install-win10))で動作確認をしています.  
検証済みの環境は[こちら](https://github.com/akikuno/DAJIN/blob/master/docs/TESTED_SYSTEMS.md)です.  

### `conda`をインストールします


wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
chmod +x Miniconda3-latest-Linux-x86_64.sh
./Miniconda3-latest-Linux-x86_64.sh

condaおよびインストールについての詳細は[こちら](https://docs.conda.io/projects/conda/en/latest/)にございます.  


### DAJINをダウンロードします

git clone https://github.com/akikuno/DAJIN.git

または下記URLでZIPファイルをダウンロードしてください.  

https://github.com/akikuno/DAJIN/archive/master.zip

### DAJINをダウンロードします


## 利用方法

### 入力ファイルの用意

以下のような入力ファイルを作製します.  

design=DAJIN/example/design.txt
input_dir=DAJIN/example/demultiplex
control=barcode01
genome=mm10
grna=CCTGTCCAGAGTGGGAGATAGCC,CCACTGCTAGCTGTGGGTAACCC
output_dir=DAJIN_cables2
threads=10
filter=on

各項目の情報は以下のとおりです. 各項目は順不同です.  

- **desing**: 考えられる遺伝型の配列を記載したFASTA形式のテキストファイルです.  ">wt"と">target"の2つは含まれている必要があります. 
- **input_dir**: demultiplex済みのFASTA/FASTQファイルを含むディレクトリです. 
- **control**: 野生型コントロールのバーコード番号です. 
- **genome**: `mm10`, `hg38`等の参照ゲノムです. 
- **grna**: PAMを含むgRNA配列です. 2つ以上の配列はコンマ（,）で区切ります. 
- **output_dir（オプショナル）**: 結果を保存するディレクトリの名前です. デフォルトは`DAJIN_results`です. 
- **threads（オプショナル）**: DAJINに使用するCPUスレッド数です. デフォルトでは`3分の2`を使用します. 
- **filter（オプショナル**: on/off）: マイナーアレル（3%以下）を解析から除きます. デフォルトは"on"です. 


### DAJINの実行

./DAJIN/DAJIN.sh -f [入力ファイルのPATH]

下記のコマンドで例を実行します.

./DAJIN/DAJIN.sh -i DAJIN/example/design.txt

### 結果のレポートについて

DAJINは2つのファイル（`Details.csv`, `Details.pdf`）と2つのフォルダ（`BAM`, `Consensus`）を出力します. 

#### Details.csv

`Details.csv` はアレル情報を記載しています.

| Sample    |  Allele ID |  % of reads |  Allele type  |  Indel |  Large indel |  Design |
|-----------|------------|-------------|---------------|--------|--------------|---------|
| barcode01 | 1          | 100         | wt            | -      | -            | -       |
| barcode02 | 1          | 11.8        | abnormal      | +      | +            | -       |
| barcode02 | 2          | 88.2        | target        | -      | -            | +       |
| barcode03 | 1          | 9.9         | abnormal      | +      | +            | -       |
| barcode03 | 2          | 38.5        | abnormal      | +      | +            | -       |
| barcode03 | 3          | 51.6        | flox_deletion | -      | -            | -       |

#### Details.pdf

`Details.pdf`は上記CSVを可視化した以下のような図です.  

<img src="https://github.com/akikuno/DAJIN/blob/master/misc/images/Details.png" width="75%">  

barcode01は野生型コントロールです. barcode02とbarcode03はfloxノックインのゲノム編集を施したファウンダーマウスの結果です.  
barcode02のほぼ全てのアレルがintact target （flox以外の異常な変異の入っていないアレル）であることから、このマウスは目的のfloxアレルをホモでもつマウスの候補と考えられます.  

#### Consensus

`Conseusus` フォルダーには各アレルのコンセンサス配列が保存されています.  
ファイル形式はFASTAおよびHTMLです.  

HTMLでは色付けされた変異情報が表示されます.  

<a href="https://htmlpreview.github.io/?https://github.com/akikuno/DAJIN/blob/master/misc/images/tyr_c140cg.html" target= _blank rel= noopener> こちらは点変異のコンセンサス配列です. </a>

#### BAM

`BAM` フォルダーには解析したサンプルの全アレルおよび各アレルごとのBAMファイルが保存されています.  
この`BAM`ファイルは[IGV](http://software.broadinstitute.org/software/igv/)で可視化できます.  

EMBED
cat <<'EMBED' >.DAJIN_temp/document/dependencies.md
# Dependencies

+ samtools (1.10)
+ minimap2 (2.17-r941)
+ Python (3.7.6)
  + numpy (1.18.5)
  + pandas (1.0.5)
  + scikit-learn (0.23.1)
  + plotnine (0.7.0)

> The number in the parenthesis represents the tested software version.
EMBED
cat <<'EMBED' >.DAJIN_temp/document/tested_systems.md
# Tested system information

We have tested DAJIN2 works in the following systems:

## Linux

---
| OS     | Ubuntu 18.04.3 LTS x86_64            |
| ------ | ------------------------------------ |
| Kernel | 5.0.0-29-generic                     |
| Shell  | bash 4.4.20                          |
| CPU    | Intel Xeon Gold 5220 (72) @ 3.900GHz |
| GPU    | NVIDIA GeForce RTX 2080 Ti x4        |
| Memory | 192 GB                               |
---
| OS     | Linux Mint 20 x86_64            |
| ------ | ------------------------------- |
| Kernel | 5.4.0-42-generic                |
| Shell  | bash 5.0.17                     |
| CPU    | AMD Ryzen 7 2700X (16) @ 3.700G |
| GPU    | NVIDIA GeForce GTX 1080 Ti      |
| Memory | 64 GB                           |

## macOS

## Windows 10 (WSL2)

---
| OS     | Ubuntu 18.04.5 LTS on Windows 10 x86_64 |
| ------ | --------------------------------------- |
| Kernel | 4.19.104-microsoft-standard             |
| Shell  | bash 4.4.20                             |
| CPU    | Intel Xeon E3-1535M v6 (8) @ 3.095GHz   |
| Memory | 64 GB                                   |
---
EMBED
cat <<'EMBED' >.DAJIN_temp/document/troubleshootings.md
# Troubleshootings

## line feed

DAJIN: 7: set: Illegal option -

This error may be caused by `CRLF`.

Please open `DAJIN` by your text editor (e.g. Visual Studio Code) and change the line feed from `CRLF` to `LF`.  

## samtools

EMBED
cat <<'EMBED' >.DAJIN_temp/document/usage.md
Usage:

  DAJIN [options] -a <alleles.fasta> -c <control.fastq> -s <sample.fastq>

Example:

  DAJIN \
    -a example/alleles.fa \
    -c example/fastq/barcode01.fq.gz \
    -s example/fastq/barcode02.fq.gz \
    -g mm10 \
    -o DAJIN_example \
    -t 4

Mandatory arguments:

  -a|--alleles <string>
    Name of a multi-fasta file describing DNA sequence of each alleles in specific regions of interest.

  -c|--control <string>
    Name of a fastq file from a control sample.
    Acceptable formats include gzipped FASTQ and FASTQ.

  -s|--sample <string>
    Name of a fastq file from an experimental sample.
    Acceptable formats include gzipped FASTQ and FASTQ.

Optional arguments (defaults in parentheses):

  -g|--genome <string>
    Name of UCSC genome releases.
    The available genomes are listed at https://genome.ucsc.edu/FAQ/FAQreleases.html#release1

  -t|--threads <integer>
    Number of threads to use (1)

  -o|--output <string>
    Output directory (DAJIN_results)

See the further information: <https://github.com/akikuno/DAJIN2>

EMBED
cat <<'EMBED' >.DAJIN_temp/document/version.md
DAJIN - Genotyping software using Nanopore long-read sequencer for genome-edited samples
Version: 2.0.2
License: MIT
Written by Akihiro Kuno
<https://github.com/akikuno/DAJIN2>.
EMBED
cat <<'EMBED' >.DAJIN_temp/library/calc_hotelling.sh
#!/bin/sh

calc_hotelling() (
  if [ -p /dev/stdin ] && [ _"$*" = _"" ]; then
    cat -
  elif [ -r "$*" ]; then
    cat "$*"
  else
    echo "$*"
  fi |
    awk '{
      data[NR]=$0
      sum+=$1
    } END {
      mean=sum/NR
      for(i=1;i<=NR;i++) {
        residual+=(data[i]-mean)^2
      }
      var=residual/NR
      for(i=1;i<=NR;i++) {
        hotelling=(data[i]-mean)^2/var
        print hotelling
      }
    }'
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/colTable.R
#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly = TRUE)
if (length(args) > 0) {
  df <- read.table(args[1], sep = ",", header = FALSE, row.names = 1)
} else {
  df <- read.table(".DAJIN_temp/tmp_expansion_barcode30_inversion.csv", sep = ",", header = FALSE, row.names = 1)
}

list_table <- apply(df, 2, table)

for (idx in seq(length(list_table))) {
  values <- names(list_table[[idx]])
  values <- as.integer(values)
  for (val in values[values > 0]) {
    df[[idx]][df[[idx]] == val] <-
      list_table[[idx]][values == val]
  }
}

write.table(df,
  file = "",
  sep = ",", col.names = FALSE, row.names = TRUE, quote = FALSE
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/fmt_fa.sh
#!/bin/sh

fmt_fa() {
  cat "$1" |
    awk 'BEGIN{RS=">"} {
      $1=">" $1 " "
      for(i=1;i<=NF;i++) printf $i
      print ""
      }' |
    awk 'NF==2'
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/general.sh
#!/bin/sh

error_exit() {
  echo "ERROR: $1" >&2
  echo "ERROR: $1" >>log_DAJIN.txt
  [ "${TEST:-}" ] || rm -rf .DAJIN_temp/ 2>/dev/null
  exit 1
}

terminate() {
  trap '' TERM
  kill -TERM 0
  [ "${TEST:-}" ] || rm -rf .DAJIN_temp/ 2>/dev/null
  exit "$1"
}
trap "terminate 130" INT
trap "terminate 143" TERM

timestamp() {
  echo "$(date +'%Y-%m-%d %H:%M:%S') | $*"
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/midsToscore.sh
#!/bin/sh
# shellcheck disable=SC1091,SC2120

################################################################################
# input: MIDS (id, MIDS)
# output: MIDS score (id, I, D, S)
################################################################################

expansion() {
  cat "$1" |
    awk -F, '
    function mids_score(I,D,S) {
      $(i+(LEN)*0)=I
      $(i+(LEN)*1)=D
      $(i+(LEN)*2)=S
    }
    function invToD(data) {
      id=$1
      gsub(/[mids]/, "D", $0)
      $1=id
    }
    BEGIN {OFS=","} {
    LEN=NF-1
    invToD($0)
    for(i=2;i<=NF;i++) {
      if($i=="M")
        mids_score(0,0,0)
      else if ($i~/[0-9]+M/) {
        sub("M$","",$i)
        mids_score($i,0,0)
        }
      else if ($i~/[0-9]+D/) {
        sub("D$","",$i)
        mids_score($i,1,0)
      }
      else if ($i~/[0-9]+S/) {
        sub("S$","",$i)
        mids_score($i,0,1)
      }
      else if($i=="D") {
        mids_score(0,1,0)
      }
      else if($i=="S") {
        mids_score(0,0,1)
      }
    }
  }1'
}

mutToat() {
  awk '
    BEGIN {
      FS=","
      OFS=""
    } {
    $1=$1","
    for (i=2; i<=NF; i++) {
      if ($i>0 && $(i+1)>0)
        $i="@"
      else if ($(i-1)=="@" && $i==1)
        $i="@,"
      else
        $i=$i","
    }
    sub(",$", "", $NF)
  }1'
}

atToscore() {
  awk '
    BEGIN {
      FS=","
      OFS=","
    } {
    for (i=2; i<=NF; i++) {
      n=""
      if ($i ~ /@/) {
        num=length($i)
        for (j=1; j<=num; j++) n=n num ","
        sub(",$", "", n)
        $i=n
      }
    }
  }1'
}

rowScore() {
  cat "$1" |
    mutToat |
    atToscore
}

colScore() {
  Rscript --vanilla .DAJIN_temp/library/colTable.R "$1"
}

rowColSums() {
  Rscript --vanilla .DAJIN_temp/library/rowColSums.R "$1" "$2"
}

midsToscore() {
  mkdir -p .DAJIN_temp
  suffix="${1##*/}"
  expansion "$1" >.DAJIN_temp/tmp_expansion_"$suffix"
  rowScore .DAJIN_temp/tmp_expansion_"$suffix" >.DAJIN_temp/tmp_row_"$suffix"
  colScore .DAJIN_temp/tmp_expansion_"$suffix" >.DAJIN_temp/tmp_col_"$suffix"
  rowColSums .DAJIN_temp/tmp_row_"$suffix" .DAJIN_temp/tmp_col_"$suffix"
  # rm .DAJIN_temp/tmp_*"$suffix"
}
EMBED
cat <<'EMBED' >.DAJIN_temp/library/rowColSums.R
#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly = TRUE)

df_row <- read.table(args[1], sep = ",", header = FALSE, row.names = 1)
df_col <- read.table(args[2], sep = ",", header = FALSE, row.names = 1)

# df_row <- read.table(".DAJIN_temp/tmp_row_barcode30_inversion.csv", sep = ",", header = FALSE, row.names = 1)
# df_col <- read.table(".DAJIN_temp/tmp_col_barcode30_inversion.csv", sep = ",", header = FALSE, row.names = 1)
df <- df_row + df_col

write.table(df,
  file = "",
  sep = ",", col.names = FALSE, row.names = TRUE, quote = FALSE
)
EMBED
cat <<'EMBED' >.DAJIN_temp/library/samTomids.sh
#!/bin/sh
# shellcheck disable=SC1091,SC2120

################################################################################
# input: SAM file using `minimap2 -ax splice --cs=long`
# output: Match(M), Insertion(1M), Deletion(D), Substitution(S), Inversion (mids) and "= (null)"
################################################################################

fmt_sam() {
  cat - |
    awk '
    /^@SQ/ {
      for(i=1;i<=NF;i++) {
        if($i ~ /^SN:/) allele=$i
        if($i ~ /^LN:/) reflen=$i
      }
      sub(/.*SN:/,"", allele)
      sub(/.*LN:/,"", reflen)
    }
    /cs:Z:=/ {
      id=$1; flag=$2; start=$4
      for(i=1;i<=NF;i++) if ($i ~ /^cs:Z:=/) cstag=$i
      sub("cs:Z:=","",cstag)
      gsub("=", " ", cstag)
      gsub(/\+/, " ", cstag)
      gsub(/\-/, " -", cstag)
      gsub(/\*/, " *", cstag)
      gsub("~", " ~", cstag)
      $1=id","flag","start","allele","reflen
      $2=cstag
      print $1,$2
    }' |
    sort -t "," -k 3,3n
}

matchToM() {
  awk '{for(i=2;i<=NF;i++) gsub(/[ACGT]/, "M ", $i)}1'
}

subToS() {
  awk '{for(i=2;i<=NF;i++) gsub(/\*[acgt][acgt]/, "S ", $i)}1'
}

delToD() {
  awk '{
      for(i=2;i<=NF;i++) {
        if($i ~ /^-/) {
          str=""
          for(j=1;j<=int(length($i)-1);j++) str=str "D "
          $i=str
        }
      }}1'
}

insToNum() {
  awk '{
    for(i=3;i<=NF;i++) {
      if($i~/^[acgt]/){
        $i=length($i) $(i+1)
        $(i+1)=""
      }
    }}1'
}

padding() {
  awk '{
    start=$2-1
    end=$3
    len=NF-3+start
    pad_start=""
    pad_end=""
    for(i=1;i<=start;i++) pad_start=pad_start "D "
    $4=pad_start $4
    for(i=len;i<end;i++) pad_end=pad_end " D"
    $NF=$NF pad_end
  }1' |
    sed "s/  */ /g"
}

spaceTocomma() {
  sed -e "s/  */,/g" -e "s/,$//"
}

samTomids() (
  if [ -p /dev/stdin ] && [ "$#" -eq 0 ]; then
    cat -
  elif [ -r "$1" ]; then
    cat "$1"
  else
    echo "$*"
  fi |
    # cat test/samTomids/in/test_inv.sam |
    fmt_sam |
    matchToM |
    subToS |
    delToD |
    awk '{$1=$1","}1' |
    #* Large deletion and Inversion -------------------------
    awk -F, '
      function padD(iter,    i,str) {
        for (i=1; i<=iter; i++) str=str " D "
        return str
      }

      function ins_rm(string) {
        gsub("[acgt][acgt]*", "", string)
        return string
      }

      function csCat(c_of, s_of, iter,    i,cs) {
        for(i=1; i<=iter; i++) {
          _cs=c_of[i]
          ins_rm(_cs)
          gap_length=s_of[i+1] - s_of[i] - gsub(/[MIDSmids]/, "", _cs)
          cs=cs c_of[i] padD(gap_length)
        }
        cs=cs c_of[iter+1]
        return cs
      }

    {
      num_of_alignment[$1]++
      start_of[$1]=start_of[$1]","$3
      allele=$4
      reflen=$5
      cstag_of[$1]=cstag_of[$1]","$6
    } END {
      for (read_id in num_of_alignment) {
        sub(/^,/, "" ,start_of[read_id])
        sub(/^,/, "" ,cstag_of[read_id])
        split(start_of[read_id], s_of, ",")
        split(cstag_of[read_id], c_of, ",")
        #* normal
        if (num_of_alignment[read_id]==1) {
          cs=c_of[1]
        }
        #* large deletion
        else if (num_of_alignment[read_id]==2) {
          if (allele !~ /(control)|(wt)/) {
            c_of[1] = padD(gsub(/[MIDS]/, "", c_of[1]))
            c_of[2] = padD(gsub(/[MIDS]/, "", c_of[2]))
          }
          cs=csCat(c_of, s_of, 1)
          }
        #* inversion
        else if (num_of_alignment[read_id]==3) {
          c_of[2] = tolower(c_of[2])
          cs=csCat(c_of, s_of, 2)
        }
      print read_id, s_of[1], reflen, cs
    }}' |
    insToNum |
    padding |
    spaceTocomma |
    awk -F, 'NF==$3+3' |
    cut -d, -f 1,4- |
    grep -v "^$" |
    sort -t,
)
EMBED
. .DAJIN_temp/library/calc_hotelling.sh
. .DAJIN_temp/library/fmt_fa.sh
. .DAJIN_temp/library/general.sh
. .DAJIN_temp/library/midsToscore.sh
. .DAJIN_temp/library/samTomids.sh
ARGS="$*" && export ARGS
cat <<'EMBED' >.DAJIN_temp/script/01-init/01-init.sh
#!/bin/sh

set -eu
umask 0022
export LC_ALL=C

[ "${BASH_VERSION:-}" ] && set -o posix -o pipefail
[ "${ZSH_VERSION:-}" ] && setopt shwordsplit interactivecomments

timestamp "DAJIN $*" >log_DAJIN.txt
EMBED
cat <<'EMBED' >.DAJIN_temp/script/02-args/01-parse.sh
#!/bin/sh

[ "$#" -eq 0 ] && grep -v '```' .DAJIN_temp/document/usage.md && exit 0

while [ "$#" -gt 0 ]; do
  case "$1" in
  -h | --help)
    grep -v '```' .DAJIN_temp/document/usage.md
    exit 0
    ;;
  -v | --version)
    grep -v '```' .DAJIN_temp/document/version.md
    exit 0
    ;;

  #--- parse arguments
  -a | --alleles)
    alleles="$2"
    shift
    ;;
  -c | --control)
    control="$2"
    shift
    ;;
  -s | --sample)
    sample="$2"
    shift
    ;;
  -g | --genome)
    genome="$2"
    shift
    ;;
  -o | --output)
    output_dir="$2"
    shift
    ;;
  -t | --threads)
    threads="$2"
    shift
    ;;

  #--- error handling
  -*) echo "Unrecognized option: $1" && exit 1 ;;
  *) echo "Unrecognized argument: $1" && exit 1 ;;
  esac
  shift
done

################################################################################
# Check arguments
################################################################################

# Check mandatory arguments ------------

echo "$ARGS" |
  grep -q -e "\-a " -e "\--alleles " ||
  error_exit "-a|--alleles argument is required"

[ -r "$alleles" ] || error_exit "$alleles is not found"

grep -q -e '>wt' -e ">control" "$alleles" ||
  error_exit "$alleles must include '>control' or '>wt'"

echo "$ARGS" |
  grep -q -e "\-c " -e "\--control " ||
  error_exit "-c|--control argument is required"

[ -r "$control" ] || error_exit "$control is not found"

echo "$ARGS" |
  grep -q -e "\-s " -e "\--sample " ||
  error_exit "-s|--sample argument is required"

[ -r "$sample" ] || error_exit "$sample is not found"

# Check optional arguments ------------
EMBED
cat <<'EMBED' >.DAJIN_temp/script/02-args/02-depend.sh
#!/bin/sh

################################################################################
# Chech dependencies
################################################################################

# curl or wget ------------------------------------------------

if type wget >/dev/null 2>&1; then
  CMD_CHECK='wget -q -O - --spider --tries=2 --wait=1 --timeout=5'
  CMD_GET='wget -q -O -'
elif type curl >/dev/null 2>&1; then
  CMD_CHECK='curl --retry 2 --retry-delay 1 -s -o /dev/null -w "%{http_code}"'
  CMD_GET='curl -s'
else
  error_exit 'No HTTP-GET/POST command found.'
fi

# Commands ------------------------------------------------

cat <<EOF |
  minimap2
  samtools
  gzip
  python
EOF
  while read -r CMD; do
    "$CMD" --version >/dev/null 2>&1 || error_exit "$CMD: command not found"
  done

# R packages ----------------------------------------------
# Rscript --slave --vanilla .DAJIN_temp/library/install_pkgs.R 1>/dev/null 2>&1

# Rscript --slave --vanilla -e "installed.packages()" >.DAJIN_temp/rpackages

# cat <<EOF |
#   dbscan
#   ggplot2
#   RColorBrewer
# EOF
#   while read -r RPKG; do
#     grep -q "$RPKG" .DAJIN_temp/rpackages || error_exit "$RPKG: package not found in R"
#   done

# rm .DAJIN_temp/rpackages

# Python packages ----------------------------------------

pip freeze >.DAJIN_temp/pypackages

cat <<EOF |
  numpy
  pandas
  scikit-learn
  hdbscan
  joblib
  plotnine
EOF
  while read -r PYPKG; do
    grep -q "$PYPKG" .DAJIN_temp/pypackages || error_exit "$PYPKG: package not found in Python"
  done

rm .DAJIN_temp/pypackages
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/010-fasta.sh
#!/bin/sh

. .DAJIN_temp/library/fmt_fa.sh

mkdir -p .DAJIN_temp/fasta/

fmt_fa "${alleles}" |
  while read -r line; do
    output="$(echo ${line#>} | cut -d " " -f 1)"
    echo "$line" | tr " " "\n" >.DAJIN_temp/fasta/"$output".fa
  done
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/020-sam.sh
#!/bin/sh

#----------------------------------------------------------
echo "$(date +'%Y-%m-%d %H:%M:%S') Generate SAM files" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/sam
control_name="$(basename "$control" | sed "s/\..*$//" | tr " " "_")"
sample_name="$(basename "$sample" | sed "s/\..*$//" | tr " " "_")"

find .DAJIN_temp/fasta/*.fa |
  while read -r allele; do
    allele_name="$(basename ${allele%.fa})"

    if [ -s /tmp/"$control_name"_"$allele_name".sam ]; then
      cp /tmp/"$control_name"_"$allele_name".sam \
        .DAJIN_temp/sam/"$control_name"_"$allele_name".sam
    else
      minimap2 -t "$threads" -ax map-ont "$allele" "$control" --cs=long 2>/dev/null |
        tee /tmp/"$control_name"_"$allele_name".sam |
        cat >.DAJIN_temp/sam/"$control_name"_"$allele_name".sam
    fi

    minimap2 -t "$threads" -ax map-ont "$allele" "$sample" --cs=long 2>/dev/null |
      cat >.DAJIN_temp/sam/"$sample_name"_"$allele_name".sam
  done
EMBED
cat <<'EMBED' >.DAJIN_temp/script/03-preprocess/030-mids.sh
#!/bin/sh

#----------------------------------------------------------
timestamp "MIDS encoding" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/mids /tmp/mids

multi_samTomids() {
  cmd='. .DAJIN_temp/library/samTomids.sh; samTomids '
  find .DAJIN_temp/sam/"$1"*.sam |
    while read -r line; do
      output="${line%.*}".csv
      output="$(echo $output | sed "s|/sam/|/mids/|")"
      echo "$line" |
        sed "s|^|$cmd|" |
        sed "s|$| >$output \&|"
    done |
    awk -v th="${threads:-1}" '
    {if (NR%(th+1) == 0) print "wait"}
    END {print "wait"}1' |
    sh
}

if find /tmp/mids/"$control_name"* 1>/dev/null 2>&1; then
  find /tmp/mids/* |
    while read -r line; do
      gzip -dc "$line" >.DAJIN_temp/mids/"$(basename ${line%.gz})"
    done
else
  multi_samTomids "$control_name"
  find .DAJIN_temp/mids/"$control_name"* |
    while read -r line; do
      gzip -c "$line" >/tmp/mids/"$(basename $line)".gz
    done
fi

multi_samTomids "$sample_name"
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/002-score.sh
#!/bin/sh

#----------------------------------------------------------
timestamp "MIDS scoring" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/score /tmp/score

multi_midsToscore() {
  cmd='. .DAJIN_temp/library/midsToscore.sh; midsToscore '
  find .DAJIN_temp/mids/"$1"*.csv |
    while read -r line; do
      output="${line%.*}".csv
      output="$(echo $output | sed "s|/mids/|/score/|")"
      echo "$line" |
        sed "s|^|$cmd|" |
        sed "s|$| >$output \&|"
    done |
    awk -v th="${threads:-1}" '
    {if (NR%(th+1) == 0) print "wait"}
    END {print "wait"}1' |
    sh
}

if find /tmp/score/"$control_name"* 1>/dev/null 2>&1; then
  find /tmp/score/* |
    while read -r line; do
      gzip -dc "$line" >.DAJIN_temp/score/"$(basename ${line%.gz})"
    done
else
  multi_midsToscore "$control_name"
  find .DAJIN_temp/score/"$control_name"* |
    while read -r line; do
      gzip -c "$line" >/tmp/score/"$(basename $line)".gz
    done
fi

multi_midsToscore "$sample_name"
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/005-classif.sh
################################################################################
cat <<EOF >>log_DAJIN.txt
==========================================================
Classify alleles...
==========================================================
EOF
################################################################################

mkdir -p .DAJIN_temp/classif

find .DAJIN_temp/score/"$sample_name"_* |
  while read -r line; do
    cat <<____EOF
    awk -F, -v sample="${sample_name}" 'BEGIN {OFS=","} {
      sum=0
      allele=FILENAME
      sub(".*"sample"_", "", allele)
      sub(".csv$", "", allele)
      for(i=2;i<=NF;i++) sum+=\$i
      print sum, allele, \$0
    }' "$line" > "${line%.csv}"_tmp &
____EOF
  done |
  awk '1; END {print "wait"}' |
  sh

cat .DAJIN_temp/score/"$sample_name"*_tmp |
  awk -F, '{
    score=$1; allele=$2; id=$3
    if(score_of[id] == "") score_of[id]="inf"
    if(score_of[id]>score) {
      score_of[id]=score; seq[id]=$0
    }} END {for(id in seq) print seq[id]}' |
  cut -d "," -f 2- |
  sort -t, |
  cat >.DAJIN_temp/classif/"$sample_name"_id_score.csv

rm .DAJIN_temp/score/"$sample_name"*_tmp
EMBED
cat <<'EMBED' >.DAJIN_temp/script/04-phasing/010-svcall.sh
#!/bin/sh

#----------------------------------------------------------
echo "$(date +'%Y-%m-%d %H:%M:%S') SV allele detetction" >>log_DAJIN.txt
#----------------------------------------------------------

mkdir -p .DAJIN_temp/sv

. .DAJIN_temp/library/calc_hotelling.sh

normalize() {
  awk -F, '{sum=0; for(i=2; i<=NF; i++) sum+=$i; print log(sum/(NF-1))}'
}

# Hotelling to remove SV in control sample
find .DAJIN_temp/score/"$control_name"_* |
  grep -e "_control.csv" -e "_wt.csv" |
  xargs cat |
  normalize |
  tee .DAJIN_temp/sv/tmp_score |
  calc_hotelling |
  cat >.DAJIN_temp/sv/tmp_hotelling

paste .DAJIN_temp/sv/tmp_score .DAJIN_temp/sv/tmp_hotelling |
  awk '$2 < 3.841459 {print $1}' | #qchisq(0.95,1)
  cat >.DAJIN_temp/sv/tmp_control

# LOFだと値が小さすぎる（きれいにマッピングされすぎる）リードもSVと判定されてしまうため,
# 中央値よりも値が小さいリードはすべて正常と判定させる.
median_score=$(
  sort -n .DAJIN_temp/sv/tmp_control |
    awk -v wc="$(wc -l <.DAJIN_temp/sv/tmp_control)" 'NR==int(wc/2)'
)

cat .DAJIN_temp/sv/"$sample_name"_id_score.csv |
  sort -t, |
  join -t "," - .DAJIN_temp/sv/allele_length |
  cut -d "," -f 3- |
  awk -F, '{sum=0; for(i=1; i<=NF-1; i++) sum+=$i; print log(sum/$NF)}' |
  cat >.DAJIN_temp/sv/tmp_sample

cat .DAJIN_temp/sv/tmp_sample |
  awk -v median="$median" '{
    ($0<median) ? $0="normal" : $0="SV_candidate"
  }1' >.DAJIN_temp/sv/tmp_sample_median

python .DAJIN_temp/library/lof_novelty.py -t "$threads" \
  -c .DAJIN_temp/sv/tmp_control -s .DAJIN_temp/sv/tmp_sample |
  awk '{($1 == 1) ? $1="normal" : $1="SV"}1' |
  paste - .DAJIN_temp/sv/tmp_sample_median |
  awk '{if($1=="SV" && $2=="normal") $1="normal"; print $1}' |
  paste -d "," - .DAJIN_temp/sv/"$sample_name"_id_score.csv |
  cut -d, -f 1-3 |
  sed "s/^/$sample_name,/" |
  awk -F, 'BEGIN{OFS=","} {print $2,$3,$4,$1}' |
  sort >.DAJIN_temp/sv/anomaly_id_"$sample_name".csv
EMBED
. .DAJIN_temp/script/01-init/01-init.sh
. .DAJIN_temp/script/02-args/01-parse.sh
. .DAJIN_temp/script/02-args/02-depend.sh
. .DAJIN_temp/script/03-preprocess/010-fasta.sh
. .DAJIN_temp/script/03-preprocess/020-sam.sh
. .DAJIN_temp/script/03-preprocess/030-mids.sh
. .DAJIN_temp/script/04-phasing/002-score.sh
. .DAJIN_temp/script/04-phasing/005-classif.sh
. .DAJIN_temp/script/04-phasing/010-svcall.sh
